import os
import json
import subprocess
import time

executed = []
summary_dir = '/mnt/summaries'
output_dir = "/mnt/reports"
available_tools = ["openvpn", "nmap", "gobuster", "nikto", "ffuf", "httpie", "whatweb", "wpscan", "dnsutils", "dig", "dnsrecon", "smtp-user-enum", "swaks", "lftp", "ftp", "hydra", "onesixtyone", "snmp", "snmpcheck",
                   "smbclient", "smbmap", "enum4linux", "rpcbind", "nbtscan", "chromium", "seclists", "curl", "wget", "git", "unzip", "iproute2", "net-tools", "traceroute", "python3", "python3-pip", "golang", "netcat-traditional"]


if not os.path.exists(output_dir):
    os.makedirs(output_dir)

if not os.path.exists(summary_dir):
    os.makedirs(summary_dir)


def get_file(fname):
    return os.path.join('/', 'mnt', 'reports', fname)


def post_step(command, command_output_file, llm_client):
    command = ' '.join(command)
    executed.append(command)
    command_output = None
    try:
        with open(command_output_file, 'r') as file:
            command_output = file.read()
    except FileNotFoundError:
        return f"Error: File not found at {command_output_file}"

    prompt = f"""
You are a security assistant analyzing the output of the following command:

{command}

Your task is to:

1. Provide a **bullet-point summary** of the findings. Focus on services, versions, possible vulnerabilities, and anything unusual and include all findings.
2. Recommend a list of **next commands to run**, based on the current output and the tools available. These should assist in further reconnaissance, vulnerability discovery, or exploitation.

### Constraints & Guidelines:
- Use only the following tools: {str(available_tools)}
- **Avoid recommending brute-force attacks.**
- Do **not** include commands that were already executed: {executed}
- Each command output **must** be saved to a file using the format:
  `/mnt/reports/toolname_uuid.txt`
  - `toolname` should reflect the tool used (e.g., `nikto`, `gobuster`, etc.)
  - `uuid` should be a **static-looking identifier**, generated by you (the LLM), not dynamically by the command itself.
  - If possible include supress debug output flag in the command to reduce log length when the command is executed
- The summary must be **clear, simple**, and written as **bullet points**.
- If any services were discoverd in the output include that in the output as well, if none found empty list
- **Do not recommend duplicate tools** (e.g., Gobuster twice).
- **Do not wrap your response in markdown or code block syntax**.
- **Only return a valid JSON object** that can be parsed by `json.loads()`.

### Example Output Format:
{{
  "summary": "<summary_text>",
  "recommended_steps": [
    "<command_1>",
    "<command_2>"
  ], 
  "services_found": [
    "<service_1>",
    "<service_2>"
  ]
}}

### Command Output:
{command_output}

If the command output does not look like a valid result (e.g., malformed or irrelevant), simply respond with:
`None`
"""

    return llm_client.get_response(prompt=prompt)


def executive_summary(llm_client):
    pass


def execute(command, llm_client):
    tool = command[0]
    print(f"[+] Executing: {command}")
    try:
        # Run the Nmap command using subprocess
        log_file = os.path.join(
            output_dir, f"{tool}_log_{time.time()*1000}.txt")
        with open(log_file, "w") as log:
            # Run the Nmap command using subprocess and capture stdout and stderr in both log and console
            process = subprocess.Popen(
                command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

            try:
                # Output stdout to both console and log file
                for line in process.stdout:
                    print(line, end='')  # Print to console
                    log.write(line)  # Write to log file

                # Output stderr to both console and log file
                for line in process.stderr:
                    print(line, end='')  # Print to console
                    log.write(line)  # Write to log file

                # Wait for the process to complete with a timeout of 300 seconds (5 minutes)
                process.wait(timeout=300)
            except subprocess.TimeoutExpired:
                # If the process takes longer than 5 minutes, terminate it
                process.terminate()
                log.write("Process terminated due to 5-minute timeout\n")
                print("Process terminated due to 5-minute timeout")

        print(f"[+] {tool} execution completed. Results saved to {log_file}")
    except subprocess.CalledProcessError as e:
        print(f"[!] Error running Nmap scan: {e}")
        return None

    print('[*] Summarizing output of', tool)
    resp = post_step(command, log_file, llm_client)
    print(resp)
    resp = json.loads(resp)

    with open(os.path.join(summary_dir, f'{tool}_summary_{int(round(time.time() * 1000))}'), "w") as file:
        file.write('[*] ' + ' '.join(command) + '\n')
        file.write(str(str(resp)))

    return resp['recommended_steps']


def workflow(llm_client, machine_ip):

    # Perform nmap scan
    nmap_command = [
        "nmap", "-sC", "-sV", "-p-", machine_ip
    ]
    recommended_steps = execute(nmap_command, llm_client)

    # Execute recommended commands
    for command in recommended_steps:
        execute(command.split(' '), llm_client)

    # # Perform nmap scan and get summary and recommended steps
    # nmap_scan(machine_ip=machine_ip)
    # file_path = get_file(f'nmap_scan_{default_file_name}.xml')
    # post_nmap_resp = ask_llm.post_nmap(file_path, llm_client)
    # post_nmap_resp = json.loads(post_nmap_resp)
    # summary = post_nmap_resp['summary']
    # recommended_steps = post_nmap_resp['recommended_steps']
    # with open(os.path.join(summary_dir, 'nmap_summary'), "w") as file:
    #     file.write(str(post_nmap_resp))
